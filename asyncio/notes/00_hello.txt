https://github.com/concurrency-in-python-with-asyncio

Предполагается, что код, используемый в нескольких главах, помещен в модуль util; мы создадим его в главе 2. Предполагается также, что для каждого отдельного листинга будет создан модуль с именем chapter_{номер_главы}, а код будет помещен в файл с именем listing_{номер_главы}_{номер_листинга}.py, принадлежащий этому модулю. Например, код из листинга 2.2 в главе 2 должен находиться в файле listing_2_2.py, принадлежащем модулю chapter_2.
=====================================================
Конкурентность
Говоря, что две задачи выполняются конкурентно, мы имеем в виду,что они работают в одно и то же время. Делаем одно пока другое ожидает, потом переключаемся(один повар).
------------------------------------------------------
Параллелизм
Говоря о параллельной работе, мы имеем в виду, что две задачи или более не просто чередуются, а выполняются строго в одно и то же время. Два дела делаются одновременно(два повара).
На машине с одним ядром это невозможно, необходимо иметь процессор с несколькими ядрами.
-------------------------------------------------------
Вытесняющая многозадачность
В этой модели мы позволяем операционной системе решить, как переключаться между выполняемыми задачами с по­мощью процедуры квантования времени.
------------------------------------------------------
Кооперативная многозадачность
В этой модели мы не полагаемся для переключения между задачами на операционную систему, а явно определяем в коде приложения точки, где можно уступить управление другой задаче.
В asyncio для организации конкурентности используется кооперативная многозадачность. Когда приложение доходит до точки, в которой может подождать результата, мы явно помечаем это в коде.
======================================================
Процесс
Процессом называется работающее приложение, которому выделена область памяти, недоступная другим приложениям.
------------------------------------------------------
Поток
Потоки можно представлять себе как облегченные процессы. Кроме того, это наименьшая единица выполнения, которая может управляться операционной системой. У потоков нет своей памяти, они пользуются памятью создавшего их процесса. Потоки ассоциированы с процессом, создавшим их. С каждым процессом всегда ассоциирован по меньшей мере один поток, обычно называемый главным. Процесс может создавать дополнительные потоки, которые обычно называются рабочими или фоновыми.
======================================================
Глобальная блокировка интерпретатора и создаваемые ей проблемы для конкурентности.
Глобальная блокировка интерпретатора (global interpreter lock – GIL)
не дает Python-процессу исполнять более одной команды байт-кода в каждый момент времени.
!!!ПРИМЕЧАНИЕ Многопроцессные приложения могут конкурентно выполнять несколько команд байт-кода, потому что у каждого Python-процесса своя собственная GIL.
------------------------------------------------------
GIL блокировка интерпретатора освобождается на время выполнения операций ввода-вывода. Это позволяет использовать потоки для конкурентного выполнения ввода-вывода, но не для выполнения счетного кода, написанного на Python (есть исключения).
В случае ввода-вывода низкоуровневые системные вызовы работают за пределами среды выполнения Python. Это позволяет освободить GIL, потому что код операционной системы не взаимодействует напрямую с объектами Python.
------------------------------------------------------
В asyncio используется тот факт, что операции ввода-вывода освобождают GIL, что позволяет реализовать конкурентность даже в одном потоке.
======================================================
Как неблокирующие сокеты позволяют добиться конкурентного выполнения в одном потоке.
------------------------------------------------------
Сокет – это низкоуровневая абстракция отправки и получения данных по сети.
Если нужно получить содержимое страницы example.com, то мы открываем сокет, подключенный к серверу example.com. Затем записываем в сокет запрос и ждем ответа от сервера, в данном случае HTML-кода веб-страницы.
По умолчанию сокеты блокирующие. Это значит, что на все время ожидания ответа от сервера приложение приостанавливается или блокируется.
На уровне операционной сокеты могут работать в неблокирующем режиме, когда мы просто начинаем операцию чтения или записи и забываем о ней, а сами занимаемся другими делами. Но позже операционная система уведомляет нас о том, что байты получены, и в этот момент мы можем уделить им внимание.
------------------------------------------------
Цикл событий – паттерн проектирования, создаем очередь, в которой хранится список событий или сообщений, а затем входим в бесконечный цикл, где обрабатываем сообщения по мере их поступления. На каждой итерации проверяется, завершилась ли какая-нибудь операция ввода-вывода; если да, то ожидавшие ее завершения задачи пробуждаются и им предоставляется возможность продолжить работу.
------------------------------------------------
